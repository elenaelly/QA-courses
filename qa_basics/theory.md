# Курс Основы тестирования программного обеспечения (Интуит)

## Понятие тестирования 

Качество программного продукта характеризуется набором свойств, определяющих, насколько продукт "хорош" с точки зрения заинтересованных сторон (заказчик продукта, спонсор, конечный пользователь, разработчики и тестировщики продукта, инженеры поддержки, сотрудники отделов маркетинга, обучения и продаж). 

Тестирование = способ обеспечения качества разработки ПО. 

Тестирование = выполнение приложения на некотором множестве исходных данных и сверке получаемых результатов с заранее известными (эталонными) с целью установить соответствие различных свойств и характеристик приложения заказанным свойствам. 

Тестирование = процесс выполнения ПО системы или компонента в условиях анализа или записи получаемых результатов с целью проверки (оценки) некоторых свойств тестируемого объекта.

Тестирование = процесс анализа пункта требований к ПО с целью фиксации различий между существующим состоянием ПО и требуемым (что свидетельствует о проявлении ошибки) при экспериментальной проверке соответствующего пункта требований.

Тестирование = контролируемое выполнение программы на конечном множестве тестовых данных и анализ результатов этого выполнения для поиска ошибок.

## Трудозатраты в тестировании

Наибольший эффект в снижении трудоемкости может быть получен прежде всего на фазах Design и Testing. Поэтому основные вложения в автоматизацию или генерацию кода следует осуществлять, прежде всего, на этих фазах. 

Задачей ближайшего будущего является движение в сторону такого распределения трудоемкости (60%-тестирование требований, 20%- разработка, 20% -тестирование продукта), чтобы суммарная цена обнаружения большинства дефектов стремилась к минимуму за счет обнаружения дефектов на ранних фазах разработки программного продукта.

## Концепция тестирования

Существует два метода обоснования истинности формул:

- Формальный подход или доказательство применяется, когда из исходных формул-аксиом с помощью формальных процедур (правил вывода) выводятся искомые формулы и утверждения (теоремы). Вывод осуществляется путем перехода от одних формул к другим.
Преимущество формального подхода заключается в том, что с его помощью удается избегать обращений к бесконечной области значений и на каждом шаге доказательства оперировать только конечным множеством символов.

- Интерпретационный подход применяется, когда осуществляется подстановка констант в формулы, а затем интерпретация формул как осмысленных утверждений в элементах множеств конкретных значений. Истинность интерпретируемых формул проверяется на конечных множествах возможных значений. Сложность подхода состоит в том, что на конечных множествах комбинации возможных значений для реализации исчерпывающей проверки могут оказаться достаточно велики.
Интерпретационный подход используется при экспериментальной проверке соответствия программы своей спецификации

Применение интерпретационного подхода в форме экспериментов над исполняемой программой составляет суть отладки и тестирования.

## Отладка
Отладка (debug, debugging) – процесс поиска, локализации и исправления ошибок в программе.

Отладка обеспечивает локализацию ошибок, поиск причин ошибок и соответствующую корректировку программы.

## Статическое и динамическое тестирование

Статическое тестирование выявляет формальными методами анализа без выполнения тестируемой программы неверные конструкции или неверные отношения объектов программы (ошибки формального задания) с помощью специальных инструментов контроля кода – CodeChecker.

Динамическое тестирование (собственно тестирование) осуществляет выявление ошибок только на выполняющейся программе с помощью специальных инструментов автоматизации тестирования – Testbed или Testbench.

## Критерии окончания тестирования

Тестирование заканчивается, когда выполнилось или "прошло" (pass) успешно достаточное количество тестов в соответствии с выбранным критерием тестирования.

## Три фазы тестирования
Реализация тестирования разделяется на три этапа:

### Создание тестового набора (test suite) 
путем ручной разработки или автоматической генерации для конкретной среды тестирования (testing environment).

### Прогон программы на тестах, управляемый тестовым монитором (test monitor, test driver) 
с получением протокола результатов тестирования (test log).

### Оценка результатов выполнения программы на наборе тестов с целью принятия решения о продолжении или остановке тестирования.

## Основная проблема тестирования

определение достаточности множества тестов для истинности вывода о правильности реализации программы, а также нахождения множества тестов, обладающего этим свойством.

Тестирование программы на всех входных значениях невозможно.
Невозможно тестирование и на всех путях.
Следовательно, надо отбирать конечный набор тестов, позволяющий проверить программу на основе наших интуитивных представлений.

## Критерии тестирования

### Требования к идеальному критерию тестирования: он должен быть
- достаточным, т.е. показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы.
- полным, т.е. в случае ошибки должен существовать тест, который раскрывает ошибку.
- надежным, т.е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы
- легко проверяемым, например вычисляемым на тестах

Для нетривиальных классов программ не существует полного и надежного критерия.

### Классы критериев:
- Структурные критерии - используют информацию о структуре программы (критерии т.н. "белого ящика", что предполагает знание исходного текста программы или спецификации программы в виде потокового графа управления (множества всех возможных путей исполнения программы, представленное в виде графa). 

Структурная информация понятна и доступна разработчикам подсистем и модулей приложения, поэтому структурные критерии часто используется на этапах модульного и интеграционного тестирования (Unit testing, Integration testing). Структурные критерии базируются на основных элементах УГП, операторах, ветвях и путях. 

  - Условие критерия тестирования команд (критерий С0) - набор тестов в совокупности должен обеспечить прохождение каждой команды не менее одного раза. Это слабый критерий. Используется в больших программных системах, где другие критерии применить невозможно.
	
  - Условие критерия тестирования ветвей (критерий С1) - набор тестов в совокупности должен обеспечить прохождение каждой ветви не менее одного раза. Сильный и  экономичный критерий. Часто используется в системах автоматизации тестирования.

  - Условие критерия тестирования путей (критерий С2) - набор тестов в совокупности должен обеспечить прохождение каждого пути не менее 1 раза. Если программа содержит цикл, то число итераций ограничивается числом классов выходных путей. Структурные критерии не проверяют соответствие спецификации. Поэтому при успешном тестировании программы по критерию C2 мы можем не заметить ошибку, связанную с невыполнением некоторых условий спецификации требований.


- Функциональные критерии - формулируются в описании требований к ПО (критерии т.н. "черного ящика"). Контроль степени выполнения требований заказчика в программном продукте. Проблема функционального тестирования - трудоемкость, т.к. документы, фиксирующие требования к программному изделию (Software requirement specification, Functional specification и т.п.) объемны.

Виды функциональных критериев:

- Тестирование пунктов спецификации (проверка каждого тестируемого пункта не менее одного раза). 
- Тестирование классов входных данных (проверка представителя каждого класса входных данных не менее одного раза). Учет многообразия входных данных - процесс трудоемкий, что создает сложности для применения критерия
- Тестирование правил (проверка каждого правила, если входные и выходные значения описываются набором правил некоторой грамматики)
- Тестирование классов выходных данных (проверка представителя каждого выходного класса).
- Тестирование функций (проверка каждого действия, реализуемого тестируемым модулем, не менее одного раза).
- Комбинированные критерии для программ и спецификаций (проверка всех комбинаций непротиворечивых условий программ и спецификаций не менее одного раза). При этом все комбинации непротиворечивых условий надо подтвердить, а условия противоречий следует обнаружить и ликвидировать.

- Критерии стохастического тестирования - формулируются при проверке наличия заданных свойств у тестируемого приложения, средствами проверки некоторой статистической гипотезы. Стохастическое тестирование - подвид динамического тестирования, в котором генерация тестовых наборов для передачи программному обеспечению происходит случайным 
образом. Также широко распространён термин фаззинг (от англ. fuzz - покрываться слоем 
мельчайших пушинок, разлетаться).

- Мутационные критерии ориентированы на проверку свойств программного изделия. Предлагается подход, позволяющий на основе мелких ошибок оценить общее число ошибок, оставшихся в программе. Подход базируется на следующих понятиях:
 - Мутации - мелкие ошибки в программе.
 - Мутанты - программы, отличающиеся друг от друга мутациями.
Метод мутационного тестирования - в разрабатываемую программу P вносят мутации, т.е. искусственно создают программы-мутанты P1, P2... Затем программа P и ее мутанты тестируются на одном и том же наборе тестов (X,Y). Если на наборе (X,Y) подтверждается правильность программы P и, кроме того, выявляются все внесенные в программы-мутанты ошибки, то набор тестов (X,Y) соответствует мутационному критерию, а тестируемая программа объявляется правильной. Если некоторые мутанты не выявили всех мутаций, то надо расширять набор тестов (X,Y) и продолжать тестирование.

## Оценка оттестированности проекта: метрики и методика интегральной оценки

### Оценка Покрытия Программы и Проекта
Тестирование программы Р по некоторому критерию С означает покрытие множества компонентов программы P М = {m1...mk} по элементам или по связям

T = {t1...tn} - кортеж неизбыточных тестов ti.

Тест ti неизбыточен, если существует покрытый им компонент mi из M(P,C), не покрытый ни одним из предыдущих тестов t1...ti-1. Каждому ti соответствует неизбыточный путь pi - последовательность вершин от входа до выхода.

V(P,C) - сложность тестирования Р по критерию С - измеряется max числом неизбыточных тестов, покрывающих все элементы множества M(P,C)

DV(P,C,Т) - остаточная сложность тестирования Р по критерию С - измеряется max числом неизбыточных тестов, покрывающих элементы множества M(P,C), оставшиеся непокрытыми, после прогона набора тестов Т. Величина DV строго и монотонно убывает от V до 0.

TV(P,C,Т) = (V-DV)/V - оценка степени тестированности Р по критерию С.

Критерий окончания тестирования TV(P,C,Т) >= L, где (0 <= L <= 1). L - уровень оттестированности, заданный в требованиях к программному продукту.

### Метрика оттестированности приложения

Для оценки степени оттестированности часто используется УГП - управляющий граф программы. УГП многокомпонентного объекта G, содержит внутри себя два компонента G1 и G2, УГП которых раскрыты.


#### Плоская модель УГП компонента G

В результате УГП компонента G имеет такой вид, как если бы компоненты G1 и G2 в его структуре специально не выделялись, а УГП компонентов G1 и G2 были вставлены в УГП G. Для тестирования компонента G в соответствии с критерием путей потребуется прогнать тестовый набор, покрывающий следующий набор трасс графа G):

P1(G) = 1-2-3-4-5-6-7-10;
P2(G) = 1-2-3-4-6-7-10;
P3(G) = 1-2-11-16-18-14-15-7-10;
P4(G) = 1-2-11-16-17-14-15-7-10;
P5(G) = 1-2-11-16-12-13-14-15-7-10;
P6(G) = 1-2-19-20-23-22-7-10;
P7(G) = 1-2-19-20-21-22-7-10;

Оценка степени тестированности плоской модели определяется долей прогнанных трасс из набора необходимых для покрытия в соответствии с критерием С.

(1) TV(G,С) = (V-DV)/V = \sum PT_{i}(G) / (\sum P_{i}(G)),

где PTi(G) - тестовый путь ( ti ) в графе G плоской модели равен 1, если он протестирован (прогнан), или 0, если нет.

Например, если в УГП (Пример 4.1) тесты t6 и t7, которым соответствуют трассы P6 и P8, не прогнаны, то в соответствии с соотношением (1) для TV(G,С) степень тестированности будет оценена в 0.71.

#### Иерархическая модель УГП компонента G

В иерархическом УГП G входящие в его состав компоненты представлены ссылками на свои УГП G1 и G2. Для исчерпывающего тестирования иерархической модели компонента G в соответствии с критерием путей требуется прогнать следующий набор трасс:

P1(G) = 1-2-3-4-5-6-7-10;
P2(G) = 1-2-3-4-6-7-10;
P3(G) = 1-2-8-7-10;
P4(G) = 1-2-9-7-10.

Приведенный набор трасс достаточен при условии, что компоненты G1 и G2 в свою очередь исчерпывающе протестированы. Чтобы обеспечить выполнение этого условия в соответствии с критерием путей, надо прогнать все трассы: 

P11(G1)=11-16-12-13-14-15;	
P12(G1)=11-16-17-14-15;
P13(G1)=19-20-23-22;
P21(G2)=19-20-21-22;
P22(G2)=11-16-18-14-15.

Оценка тестированности иерархической модели определяется на основе учета оценок тестированности компонентов. Если трасса некоторого теста tj УГП G включает узлы, представляющие компоненты Gj1,..Gjm, оценка TV степени тестированности которых известна, то оценка тестированности PTi(G) при реализации этой трассы определяется не 1, а минимальной из оценок TV для компонентов.

Интегральная оценка определяется соотношением (2):

(2) TV(G,C) = (V-DV)/V = (\sum PT_{i}(G) * \sum (TV(G_{ij},C))) / (\sum P_{i}(G))

где PTi(G) - тестовый путь ( ti ) в графе G равен 1, если протестирован, или 0, если нет. В путь PTi графа G может входить j узлов модулей Gij со своей степенью тестированности TV(Gij,С), из которых мы берем min, что дает худшую оценку степени тестированности пути.

#### Методика интегральной оценки тестированности
1. Выбор критерия С и приемочной оценки тестированности программного проекта - L
2. Построение древа классов проекта и построение УГП для каждого модуля
3. Модульное тестирование и оценка TV на модульном уровне
4. Построение УГП, интегрирующего модули в единую иерархическую ( классовую ) модель проекта
5. Выбор тестовых путей для проведения интеграционного или системного тестирования
6. Генерация тестов, покрывающих тестовые пути шага 5
7. Интегральная оценка тестированности проекта с учетом оценок тестированности модулей-компонентов
8. Повторение шагов 5-7 до достижения заданного уровня тестированности L

## Модульное и интеграционное тестирование

### Модульное
Модульное тестирование - это тестирование программы на уровне отдельно взятых модулей, функций или классов. 
Модульное тестирование = структурное тестирование (тестирование "белого ящика"). 
Проводится по принципу "белого ящика", то есть основывается на знании внутренней структуры программы, и часто включает те или иные методы анализа покрытия кода.
Подразумевает создание вокруг каждого модуля определенной среды, включающей заглушки для всех интерфейсов тестируемого модуля. Некоторые из них могут использоваться для подачи входных значений, другие для анализа результатов, присутствие третьих может быть продиктовано требованиями, накладываемыми компилятором и сборщиком.

#### Цели:
- выявление локализованных в модуле ошибок в реализации алгоритмов
- определение степени готовности системы к переходу на следующий уровень разработки и тестирования. 

#### Дефекты
На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кода. 
Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования.

Эффективность обнаружения дефектов должна определять стратегию модульного тестирования. Можно найти вероятные прошлые ошибки путем копания в репозитории прошлых проектов, сборок (билдов). Если ничего найти не удалось - ищем локальные дефекты, у которых код, ресурсы и информация характерны именно для данного модуля. В этом случае на модульном уровне ошибки, связанные, например, с неверным порядком или форматом модуля, могут быть пропущены, поскольку они вовлекают информацию, затрагивающую другие модули (а именно, спецификацию интерфейса), в то время как ошибки в алгоритме обработки параметров довольно легко обнаруживаются.

#### Принципы проектирования тестов: 

- На основе анализа потока управления: тесты покрывают вершины, дуги, пути управляющего графа программы (УГП), условия, комбинации условий и т. п.

- На основе анализа потока данных: тесты покрывают элементы информационного графа программы.(????)

- Тестирование на основе потока управления: тесты покрывают все логические (булевые) условия в программе. 

#### Критерии:

- комбинированный критерий покрытия условий/решений: требования по покрытию решений + условий.

- критерий покрытия функций программы - каждая функция программы должна быть вызвана хотя бы один раз

- критерий покрытия вызовов (критерий покрытия пар вызовов / call pair coverage): каждый вызов каждой функции в программе должен быть осуществлен хотя бы один раз.

### Тестирование на основе потока данных
Выявление ссылок на неинициализированные переменные и избыточные присваивания. Не гарантирует покрытия решений.

### Стратегия требуемых пар
Тестируются взаимосвязи переменных в предикате и число выходов решения. 

#### Критерии:
- критерий СР: покрытие тестами всех пар дуг (???) 
- критерий Cdu: покрытие тестами пар (вершина, дуга)

### Фазы построения набора тестов

1. Конструирование УГП (статический анализ программы:получение графа программы и множества элементов, которые необходимо покрыть тестами)

2. Выбор тестовых путей.

Подходы к построению тестовых путей:

- Статические методы: построение каждого пути посредством постепенного его удлинения за счет добавления дуг, пока не будет достигнута выходная вершина управляющего графа программы. Основной недостаток статических методов заключается в том, что не учитывается возможная нереализуемость построенных путей тестирования.

- Динамические метод: построение полной системы тестов, удовлетворяющих заданному критерию; подсоединение к начальным реализуемым отрезкам путей дальнейших их частей так, чтобы: 1) не терять при этом реализуемости вновь полученных путей; 2) покрыть требуемые элементы структуры программы.

- Методы реализуемых путей: выделение из множества путей подмножества всех реализуемых путей, а затем покрывающее множество путей строится из полученного подмножества реализуемых путей.

3. Генерация тестов, соответствующих тестовым путям.

### Интеграционное тестирование
Интеграционное тестирование - это тестирование части системы, состоящей из двух и более модулей. 

На этом уровне применяются методы, связанные с покрытием интерфейсов, например, вызовов функций или методов, или анализ использования интерфейсных объектов, таких как глобальные ресурсы, средства коммуникаций, предоставляемых операционной системой.

Тестирование "белого ящика". 

Применяется на этапе сборки модульно оттестированных модулей в единый комплекс. 

#### Цель:
- поиск дефектов, связанных с ошибками в реализации и интерпретации интерфейсного взаимодействия между модулями.

#### Методы сборки модулей:

##### Монолитный

одновременное объединение всех модулей в тестируемый комплекс. Для замены неразработанных к моменту тестирования модулей, кроме самого верхнего, необходимо дополнительно разрабатывать драйверы (test driver) и/или заглушки (stub), замещающие отсутствующие на момент сеанса тестирования модули нижних уровней.
Монолитное тестирование требует больших трудозатрат, связанных с дополнительной разработкой драйверов и заглушек и со сложностью идентификации ошибок, проявляющихся в пространстве собранного кода. Монолитное тестирование предоставляет большие возможности распараллеливания работ особенно на начальной фазе тестирования.

##### Инкрементальный
Пошаговое (помодульное) наращивание комплекса программ с пошаговым тестированием собираемого комплекса. 
Пошаговое тестирование связано с меньшей трудоемкостью идентификации ошибок за счет постепенного наращивания объема тестируемого кода и соответственно локализации добавленной области тестируемого кода.

###### Стратегии добавления модулей:

####### - "Сверху вниз" и соответствующее ему нисходящее тестирование.

Организация среды для исполняемой очередности вызовов оттестированными модулями тестируемых модулей, постоянная разработка и использование заглушек, организация приоритетного тестирования модулей, содержащих операции обмена с окружением, или модулей, критичных для тестируемого алгоритма.

Недостатки:

- Проблема разработки заглушек;
- Сложность организации и разработки среды для реализации исполнения модулей в нужной последовательности;
- Параллельная разработка модулей верхних и нижних уровней приводит к не всегда эффективной реализации модулей из-за подстройки (специализации) еще не тестированных модулей нижних уровней к уже оттестированным модулям верхних уровней

- "Снизу вверх" и соответственно восходящее тестирование.

Организация порядка сборки и перехода к тестированию модулей, соответствующему порядку их реализации.

Недостатки:

- Запаздывание проверки концептуальных особенностей тестируемого комплекса
- Необходимость в разработке и использовании драйверов
- Особенности интеграционного тестирования для процедурного программирования
- Процесс построения набора тестов при структурном тестировании определяется принципом, на котором основывается конструирование Графа Модели Программы (ГМП). От этого зависит множество тестовых путей и генерация тестов, соответствующих тестовым путям.

#### Варианты построения графовой модели проекта:

- плоская модель проекта
- иерархическая модель проекта (например, Рис. 4.2, Рис. 4.3).

#### Критерии тестирования:
- критерий покрытия ветвей C1. 
