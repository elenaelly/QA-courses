# Курс "Основы тестирования программного обеспечения" (Интуит)

## Понятие тестирования 
Тестирование = способ обеспечения качества разработки ПО. 

Тестирование = выполнение приложения на некотором множестве исходных данных и сверке получаемых результатов с заранее известными (эталонными) с целью установить соответствие различных свойств и характеристик приложения заказанным свойствам. 

Тестирование = процесс выполнения ПО системы или компонента в условиях анализа или записи получаемых результатов с целью проверки (оценки) некоторых свойств тестируемого объекта.

Тестирование = процесс анализа пункта требований к ПО с целью фиксации различий между существующим состоянием ПО и требуемым (что свидетельствует о проявлении ошибки) при экспериментальной проверке соответствующего пункта требований.

Тестирование = контролируемое выполнение программы на конечном множестве тестовых данных и анализ результатов этого выполнения для поиска ошибок.

## Понятие качества ПО

Качество программного продукта характеризуется набором свойств, определяющих, насколько продукт "хорош" с точки зрения заинтересованных сторон (заказчик продукта, спонсор, конечный пользователь, разработчики и тестировщики продукта, инженеры поддержки, сотрудники отделов маркетинга, обучения и продаж). 

### Как определить свойства качественного ПО

1. Определить все лица, заинтересованные в исполнении и результатах данного проекта.
2. Определить критерии качества для каждого из участников.
3. Расставить приоритеты критериев.
4. Определить набора критериев, которые будут отслежены и выполнены в рамках проекта, исходя из приоритетов и возможностей проектной команды. 
5. Установить целей по каждому из критериев.
6. Определить способы и механизмы достижения каждого критерия.
7. Определить стратегии тестирования исходя из набора критериев, попадающих под ответственность группы тестирования, выбранных приоритетов и целей

## Трудозатраты в тестировании

Наибольший эффект в снижении трудоемкости может быть получен прежде всего на фазах Design и Testing. Поэтому основные вложения в автоматизацию или генерацию кода следует осуществлять, прежде всего, на этих фазах. 

Задачей ближайшего будущего является движение в сторону такого распределения трудоемкости (60%-тестирование требований, 20%- разработка, 20% -тестирование продукта), чтобы суммарная цена обнаружения большинства дефектов стремилась к минимуму за счет обнаружения дефектов на ранних фазах разработки программного продукта.

## Концепция тестирования

Существует два метода обоснования истинности формул:

- **Формальный подход** или доказательство применяется, когда из исходных формул-аксиом с помощью формальных процедур (правил вывода) выводятся искомые формулы и утверждения (теоремы). Вывод осуществляется путем перехода от одних формул к другим.
Преимущество формального подхода заключается в том, что с его помощью удается избегать обращений к бесконечной области значений и на каждом шаге доказательства оперировать только конечным множеством символов.

- **Интерпретационный подход** применяется, когда осуществляется подстановка констант в формулы, а затем интерпретация формул как осмысленных утверждений в элементах множеств конкретных значений. Истинность интерпретируемых формул проверяется на конечных множествах возможных значений. Сложность подхода состоит в том, что на конечных множествах комбинации возможных значений для реализации исчерпывающей проверки могут оказаться достаточно велики.
Интерпретационный подход используется при экспериментальной проверке соответствия программы своей спецификации

Применение интерпретационного подхода в форме экспериментов над исполняемой программой составляет суть отладки и тестирования.

## Отладка
Отладка (debug, debugging) – процесс поиска, локализации и исправления ошибок в программе.

Отладка обеспечивает локализацию ошибок, поиск причин ошибок и соответствующую корректировку программы.

## Статическое и динамическое тестирование

**Статическое тестирование** выявляет формальными методами анализа без выполнения тестируемой программы неверные конструкции или неверные отношения объектов программы (ошибки формального задания) с помощью специальных инструментов контроля кода – CodeChecker.

**Динамическое тестирование** (собственно тестирование) осуществляет выявление ошибок только на выполняющейся программе с помощью специальных инструментов автоматизации тестирования – Testbed или Testbench.

## Критерии окончания тестирования

Тестирование заканчивается, когда выполнилось или "прошло" (pass) успешно достаточное количество тестов в соответствии с выбранным критерием тестирования.

## Три фазы тестирования
Реализация тестирования разделяется на три этапа:

### 1. Создание тестового набора (test suite) 
путем ручной разработки или автоматической генерации для конкретной среды тестирования (testing environment).

### 2. Прогон программы на тестах, управляемый тестовым монитором (test monitor, test driver) 
с получением протокола результатов тестирования (test log).

### 3. Оценка результатов выполнения программы на наборе тестов с целью принятия решения о продолжении или остановке тестирования.

## Основная проблема тестирования

определение достаточности множества тестов для истинности вывода о правильности реализации программы, а также нахождения множества тестов, обладающего этим свойством.

Тестирование программы на всех входных значениях невозможно.
Невозможно тестирование и на всех путях.
Следовательно, надо отбирать конечный набор тестов, позволяющий проверить программу на основе наших интуитивных представлений.

## Критерии тестирования

### Требования к идеальному критерию тестирования:

- **достаточный**, т.е. показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы.
- **полный**, т.е. в случае ошибки должен существовать тест, который раскрывает ошибку.
- **надежный**, т.е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы
- **легко проверяемый**, например вычисляемым на тестах

Для нетривиальных классов программ не существует полного и надежного критерия.

### Классы критериев:

- **Структурные критерии** - используют информацию о структуре программы (критерии т.н. "белого ящика", что предполагает знание исходного текста программы или спецификации программы в виде потокового графа управления (множества всех возможных путей исполнения программы, представленное в виде графa). 

Структурная информация понятна и доступна разработчикам подсистем и модулей приложения, поэтому структурные критерии часто используется на этапах модульного и интеграционного тестирования (Unit testing, Integration testing). Структурные критерии базируются на основных элементах УГП, операторах, ветвях и путях. 

  - Условие критерия тестирования команд (критерий С0) - набор тестов в совокупности должен обеспечить прохождение каждой команды не менее одного раза. Это слабый критерий. Используется в больших программных системах, где другие критерии применить невозможно.
	
  - Условие критерия тестирования ветвей (критерий С1) - набор тестов в совокупности должен обеспечить прохождение каждой ветви не менее одного раза. Сильный и  экономичный критерий. Часто используется в системах автоматизации тестирования.

  - Условие критерия тестирования путей (критерий С2) - набор тестов в совокупности должен обеспечить прохождение каждого пути не менее 1 раза. Если программа содержит цикл, то число итераций ограничивается числом классов выходных путей. Структурные критерии не проверяют соответствие спецификации. Поэтому при успешном тестировании программы по критерию C2 мы можем не заметить ошибку, связанную с невыполнением некоторых условий спецификации требований.


- **Функциональные критерии** - формулируются в описании требований к ПО (критерии т.н. "черного ящика"). Контроль степени выполнения требований заказчика в программном продукте. Проблема функционального тестирования - трудоемкость, т.к. документы, фиксирующие требования к программному изделию (Software requirement specification, Functional specification и т.п.) объемны.

Виды функциональных критериев:

- Тестирование пунктов спецификации (проверка каждого тестируемого пункта не менее одного раза). 
- Тестирование классов входных данных (проверка представителя каждого класса входных данных не менее одного раза). Учет многообразия входных данных - процесс трудоемкий, что создает сложности для применения критерия
- Тестирование правил (проверка каждого правила, если входные и выходные значения описываются набором правил некоторой грамматики)
- Тестирование классов выходных данных (проверка представителя каждого выходного класса).
- Тестирование функций (проверка каждого действия, реализуемого тестируемым модулем, не менее одного раза).
- Комбинированные критерии для программ и спецификаций (проверка всех комбинаций непротиворечивых условий программ и спецификаций не менее одного раза). При этом все комбинации непротиворечивых условий надо подтвердить, а условия противоречий следует обнаружить и ликвидировать.

- **Критерии стохастического тестирования** - формулируются при проверке наличия заданных свойств у тестируемого приложения, средствами проверки некоторой статистической гипотезы. Стохастическое тестирование - подвид динамического тестирования, в котором генерация тестовых наборов для передачи программному обеспечению происходит случайным образом. Также широко распространён термин фаззинг.

- **Мутационные критерии** ориентированы на проверку свойств программного изделия. Предлагается подход, позволяющий на основе мелких ошибок оценить общее число ошибок, оставшихся в программе. Подход базируется на следующих понятиях:
 - Мутации - мелкие ошибки в программе.
 - Мутанты - программы, отличающиеся друг от друга мутациями.
Метод мутационного тестирования - в разрабатываемую программу P вносят мутации, т.е. искусственно создают программы-мутанты P1, P2... Затем программа P и ее мутанты тестируются на одном и том же наборе тестов (X,Y). Если на наборе (X,Y) подтверждается правильность программы P и, кроме того, выявляются все внесенные в программы-мутанты ошибки, то набор тестов (X,Y) соответствует мутационному критерию, а тестируемая программа объявляется правильной. Если некоторые мутанты не выявили всех мутаций, то надо расширять набор тестов (X,Y) и продолжать тестирование.

## Оценка оттестированности проекта: метрики и методика интегральной оценки

### Оценка Покрытия Программы и Проекта
Тестирование программы Р по некоторому критерию С означает покрытие множества компонентов программы P М = {m1...mk} по элементам или по связям

T = {t1...tn} - кортеж неизбыточных тестов ti.

Тест ti неизбыточен, если существует покрытый им компонент mi из M(P,C), не покрытый ни одним из предыдущих тестов t1...ti-1. Каждому ti соответствует неизбыточный путь pi - последовательность вершин от входа до выхода.

V(P,C) - сложность тестирования Р по критерию С - измеряется max числом неизбыточных тестов, покрывающих все элементы множества M(P,C)

DV(P,C,Т) - остаточная сложность тестирования Р по критерию С - измеряется max числом неизбыточных тестов, покрывающих элементы множества M(P,C), оставшиеся непокрытыми, после прогона набора тестов Т. Величина DV строго и монотонно убывает от V до 0.

TV(P,C,Т) = (V-DV)/V - оценка степени тестированности Р по критерию С.

Критерий окончания тестирования TV(P,C,Т) >= L, где (0 <= L <= 1). L - уровень оттестированности, заданный в требованиях к программному продукту.

### Метрика оттестированности приложения

Для оценки степени оттестированности часто используется УГП - управляющий граф программы. УГП многокомпонентного объекта G, содержит внутри себя два компонента G1 и G2, УГП которых раскрыты.


#### Плоская модель УГП компонента G

В результате УГП компонента G имеет такой вид, как если бы компоненты G1 и G2 в его структуре специально не выделялись, а УГП компонентов G1 и G2 были вставлены в УГП G. Для тестирования компонента G в соответствии с критерием путей потребуется прогнать тестовый набор, покрывающий следующий набор трасс графа G):

P1(G) = 1-2-3-4-5-6-7-10;
P2(G) = 1-2-3-4-6-7-10;
P3(G) = 1-2-11-16-18-14-15-7-10;
P4(G) = 1-2-11-16-17-14-15-7-10;
P5(G) = 1-2-11-16-12-13-14-15-7-10;
P6(G) = 1-2-19-20-23-22-7-10;
P7(G) = 1-2-19-20-21-22-7-10;

Оценка степени тестированности плоской модели определяется долей прогнанных трасс из набора необходимых для покрытия в соответствии с критерием С.

(1) TV(G,С) = (V-DV)/V = \sum PT_{i}(G) / (\sum P_{i}(G)),

где PTi(G) - тестовый путь ( ti ) в графе G плоской модели равен 1, если он протестирован (прогнан), или 0, если нет.

Например, если в УГП (Пример 4.1) тесты t6 и t7, которым соответствуют трассы P6 и P8, не прогнаны, то в соответствии с соотношением (1) для TV(G,С) степень тестированности будет оценена в 0.71.

#### Иерархическая модель УГП компонента G

В иерархическом УГП G входящие в его состав компоненты представлены ссылками на свои УГП G1 и G2. Для исчерпывающего тестирования иерархической модели компонента G в соответствии с критерием путей требуется прогнать следующий набор трасс:

P1(G) = 1-2-3-4-5-6-7-10;
P2(G) = 1-2-3-4-6-7-10;
P3(G) = 1-2-8-7-10;
P4(G) = 1-2-9-7-10.

Приведенный набор трасс достаточен при условии, что компоненты G1 и G2 в свою очередь исчерпывающе протестированы. Чтобы обеспечить выполнение этого условия в соответствии с критерием путей, надо прогнать все трассы: 

P11(G1)=11-16-12-13-14-15;	
P12(G1)=11-16-17-14-15;
P13(G1)=19-20-23-22;
P21(G2)=19-20-21-22;
P22(G2)=11-16-18-14-15.

Оценка тестированности иерархической модели определяется на основе учета оценок тестированности компонентов. Если трасса некоторого теста tj УГП G включает узлы, представляющие компоненты Gj1,..Gjm, оценка TV степени тестированности которых известна, то оценка тестированности PTi(G) при реализации этой трассы определяется не 1, а минимальной из оценок TV для компонентов.

Интегральная оценка определяется соотношением (2):

(2) TV(G,C) = (V-DV)/V = (\sum PT_{i}(G) * \sum (TV(G_{ij},C))) / (\sum P_{i}(G))

где PTi(G) - тестовый путь ( ti ) в графе G равен 1, если протестирован, или 0, если нет. В путь PTi графа G может входить j узлов модулей Gij со своей степенью тестированности TV(Gij,С), из которых мы берем min, что дает худшую оценку степени тестированности пути.

#### Методика интегральной оценки тестированности

1. Выбор критерия С и приемочной оценки тестированности программного проекта - L
2. Построение древа классов проекта и построение УГП для каждого модуля
3. Модульное тестирование и оценка TV на модульном уровне
4. Построение УГП, интегрирующего модули в единую иерархическую ( классовую ) модель проекта
5. Выбор тестовых путей для проведения интеграционного или системного тестирования
6. Генерация тестов, покрывающих тестовые пути шага 5
7. Интегральная оценка тестированности проекта с учетом оценок тестированности модулей-компонентов
8. Повторение шагов 5-7 до достижения заданного уровня тестированности L

## Модульное и интеграционное тестирование

### Модульное
Модульное тестирование - это тестирование программы на уровне отдельно взятых модулей, функций или классов. 
Модульное тестирование = структурное тестирование (тестирование "белого ящика"). 
Проводится по принципу "белого ящика", то есть основывается на знании внутренней структуры программы, и часто включает те или иные методы анализа покрытия кода.
Подразумевает создание вокруг каждого модуля определенной среды, включающей заглушки для всех интерфейсов тестируемого модуля. Некоторые из них могут использоваться для подачи входных значений, другие для анализа результатов, присутствие третьих может быть продиктовано требованиями, накладываемыми компилятором и сборщиком.

#### Цели:
- выявление локализованных в модуле ошибок в реализации алгоритмов
- определение степени готовности системы к переходу на следующий уровень разработки и тестирования. 

#### Дефекты
На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кода. 
Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования.

Эффективность обнаружения дефектов должна определять стратегию модульного тестирования. Можно найти вероятные прошлые ошибки путем копания в репозитории прошлых проектов, сборок (билдов). Если ничего найти не удалось - ищем локальные дефекты, у которых код, ресурсы и информация характерны именно для данного модуля. В этом случае на модульном уровне ошибки, связанные, например, с неверным порядком или форматом модуля, могут быть пропущены, поскольку они вовлекают информацию, затрагивающую другие модули (а именно, спецификацию интерфейса), в то время как ошибки в алгоритме обработки параметров довольно легко обнаруживаются.

#### Принципы проектирования тестов: 

- На основе анализа потока управления: тесты покрывают вершины, дуги, пути управляющего графа программы (УГП), условия, комбинации условий и т. п.

- На основе анализа потока данных: тесты покрывают элементы информационного графа программы.(????)

- Тестирование на основе потока управления: тесты покрывают все логические (булевые) условия в программе. 

#### Критерии:

- комбинированный критерий покрытия условий/решений: требования по покрытию решений + условий.

- критерий покрытия функций программы - каждая функция программы должна быть вызвана хотя бы один раз

- критерий покрытия вызовов (критерий покрытия пар вызовов / call pair coverage): каждый вызов каждой функции в программе должен быть осуществлен хотя бы один раз.

### Тестирование на основе потока данных
Выявление ссылок на неинициализированные переменные и избыточные присваивания. Не гарантирует покрытия решений.

### Стратегия требуемых пар
Тестируются взаимосвязи переменных в предикате и число выходов решения. 

#### Критерии:
- критерий СР: покрытие тестами всех пар дуг (???) 
- критерий Cdu: покрытие тестами пар (вершина, дуга)

### Фазы построения набора тестов

1. **Конструирование УГП** (статический анализ программы:получение графа программы и множества элементов, которые необходимо покрыть тестами)

2. **Выбор тестовых путей.**

Подходы к построению тестовых путей:

- Статические методы: построение каждого пути посредством постепенного его удлинения за счет добавления дуг, пока не будет достигнута выходная вершина управляющего графа программы. Основной недостаток статических методов заключается в том, что не учитывается возможная нереализуемость построенных путей тестирования.

- Динамические метод: построение полной системы тестов, удовлетворяющих заданному критерию; подсоединение к начальным реализуемым отрезкам путей дальнейших их частей так, чтобы: 1) не терять при этом реализуемости вновь полученных путей; 2) покрыть требуемые элементы структуры программы.

- Методы реализуемых путей: выделение из множества путей подмножества всех реализуемых путей, а затем покрывающее множество путей строится из полученного подмножества реализуемых путей.

3. **Генерация тестов, соответствующих тестовым путям.**

### Интеграционное тестирование

Интеграционное тестирование - это тестирование части системы, состоящей из двух и более модулей. 

На этом уровне применяются методы, связанные с покрытием интерфейсов, например, вызовов функций или методов, или анализ использования интерфейсных объектов, таких как глобальные ресурсы, средства коммуникаций, предоставляемых операционной системой.

Тестирование "белого ящика". 

Применяется на этапе сборки модульно оттестированных модулей в единый комплекс. 

#### Цель:
- поиск дефектов, связанных с ошибками в реализации и интерпретации интерфейсного взаимодействия между модулями.

#### Методы сборки модулей:

##### Монолитный

одновременное объединение всех модулей в тестируемый комплекс. Для замены неразработанных к моменту тестирования модулей, кроме самого верхнего, необходимо дополнительно разрабатывать драйверы (test driver) и/или заглушки (stub), замещающие отсутствующие на момент сеанса тестирования модули нижних уровней.
Монолитное тестирование требует больших трудозатрат, связанных с дополнительной разработкой драйверов и заглушек и со сложностью идентификации ошибок, проявляющихся в пространстве собранного кода. Монолитное тестирование предоставляет большие возможности распараллеливания работ особенно на начальной фазе тестирования.

##### Инкрементальный
Пошаговое (помодульное) наращивание комплекса программ с пошаговым тестированием собираемого комплекса. 
Пошаговое тестирование связано с меньшей трудоемкостью идентификации ошибок за счет постепенного наращивания объема тестируемого кода и соответственно локализации добавленной области тестируемого кода.

###### Стратегии добавления модулей:

-"Сверху вниз" и соответствующее ему **нисходящее тестирование.**

Организация среды для исполняемой очередности вызовов оттестированными модулями тестируемых модулей, постоянная разработка и использование заглушек, организация приоритетного тестирования модулей, содержащих операции обмена с окружением, или модулей, критичных для тестируемого алгоритма.

**Недостатки:**

- Проблема разработки заглушек;
- Сложность организации и разработки среды для реализации исполнения модулей в нужной последовательности;
- Параллельная разработка модулей верхних и нижних уровней приводит к не всегда эффективной реализации модулей из-за подстройки (специализации) еще не тестированных модулей нижних уровней к уже оттестированным модулям верхних уровней

- "Снизу вверх" и соответственно **восходящее тестирование.**

Организация порядка сборки и перехода к тестированию модулей, соответствующему порядку их реализации.

**Недостатки:**

- Запаздывание проверки концептуальных особенностей тестируемого комплекса
- Необходимость в разработке и использовании драйверов
- Особенности интеграционного тестирования для процедурного программирования
- Процесс построения набора тестов при структурном тестировании определяется принципом, на котором основывается конструирование Графа Модели Программы (ГМП). От этого зависит множество тестовых путей и генерация тестов, соответствующих тестовым путям.

#### Варианты построения графовой модели проекта:

- плоская модель проекта
- иерархическая модель проекта (например, Рис. 4.2, Рис. 4.3).

#### Критерии тестирования:
- критерий покрытия ветвей C1. 

### Системное тестирование

Системное тестирование рассматривает тестируемую систему в целом.
Оперирует на уровне пользовательских интерфейсов, в отличие от последних фаз интеграционного тестирования, которое оперирует на уровне интерфейсов модулей. 
Метод черного ящика

#### Цели:
- выявление дефектов, связанных с работой системы в целом, напр, неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство в применении и тому подобное.

#### Категории тестов:

- Полнота решения функциональных задач.
- Стрессовое тестирование - на предельных объемах нагрузки входного потока.
- Корректность использования ресурсов (утечка памяти, возврат ресурсов).
- Оценка производительности.
- Эффективность защиты от искажения данных и некорректных действий.
- Проверка инсталляции и конфигурации на разных платформах.
- Корректность документации

### Регрессионное тестирование

**Регрессионное тестирование** - цикл тестирования, который производится при внесении изменений на фазе системного тестирования или сопровождения продукта. 

Главная проблема - выбор между полным и частичным перетестированием и пополнением тестовых наборов. 

Организация повторного тестирования в условиях сокращения ресурсов, необходимых для обеспечения заданного уровня качества продукта, обеспечивается регрессионным тестированием.

#### Пример регрессионного тестирования

Получив отчет об ошибке, программист анализирует исходный код, находит ошибку, исправляет ее и модульно или интеграционно тестирует результат.

В свою очередь тестировщик, проверяя внесенные программистом изменения, должен:

1) Проверить и утвердить исправление ошибки. Для этого необходимо выполнить указанный в отчете тест, с помощью которого была найдена ошибка.
2) Попробовать воспроизвести ошибку каким-нибудь другим способом.
3) Протестировать последствия исправлений. Возможно, что внесенные исправления привнесли ошибку (наведенную ошибку) в код, который до этого исправно работал.

![image](https://user-images.githubusercontent.com/82804334/167301599-77c4d18c-c73c-41d8-8be7-5bac6e1b30ec.png)


## Ручное тестирование 

заключается в выполнении задокументированной процедуры, где описана методика выполнения тестов, задающая порядок тестов и для каждого теста - список значений параметров, который подается на вход, и список результатов, ожидаемых на выходе. Поскольку процедура предназначена для выполнения человеком, в ее описании для краткости могут использоваться некоторые значения по умолчанию, ориентированные на здравый смысл, или ссылки на информацию, хранящуюся в другом документе.

### Пример фрагмента процедуры

1. Подать на вход три разных целых числа.
2. Запустить тестовое исполнение.
3. Проверить, соответствует ли полученный результат таблице [ссылка на документ1] с учетом поправок [ссылка на документ2].
4. Убедиться в понятности и корректности выдаваемой сопроводительной информации.


## Автоматизация тестирования

Разработка тестов обычно начинается в момент согласования требований к программному продукту (выпуск Requirement Book, содержащей высокоуровневые требования к продукту) и продолжается параллельно с разработкой дизайна и кода продукта => к началу системного тестирования создаются тестовые наборы, содержащие тысячи тестов. Запуск такого количества тестов на этапе системного тестирования - проблема => нужно автоматизировать. 

### Скрипты

Вся необходимая информация должна быть явно помещена в текст (скрипт) теста.

#### Пример скрипта

1. Выдать на консоль имя или номер теста и время его начала.
2. Вызвать продукт с фиксированными параметрами.
3. Перенаправить вывод продукта в файл.
4. Проверить возвращенное продуктом значение. Оно должно быть равно ожидаемому результату, зафиксированному в тесте.
5. Проверить вывод продукта, сохраненный в файле (п.3), на равенство ожидаемому результату.
6. Выдать на консоль результаты теста в виде вердикта PASS/FAIL и в случае FAIL - краткого пояснения, какая именно проверка не прошла.
7. Выдать на консоль время окончания теста.

### Сравнение ручного и автоматизированного тестирования
![image](https://user-images.githubusercontent.com/82804334/167306249-2b53f508-3074-45f7-8ac8-a434f5f9151c.png)


### Структура системы автоматизации

![image](https://user-images.githubusercontent.com/82804334/167303301-380f020e-ccf1-4c31-939f-57b5eb5e004d.png)


В структуре системы автоматизации тестирования создаются и сохраняются:

**- Набор тестов,** достаточный для покрытия приложения.

**- Результаты прогона тестового набора,** зафиксированные в Log-файле. Log-файл содержит трассы ("протоколы"), представляющие собой реализованные при тестовом прогоне последовательности некоторых событий (значений отдельных переменных или их совокупностей) и точки реализации этих событий. 

**- Статистика тестового цикла**, содержащая: 

	1) результаты пропуска каждого теста из тестового набора и их сравнения с ожидаемым поведением; 

	2) факты, продолжать или окончить тестирование; 

	3) критерий покрытия и степень его удовлетворения в цикле тестирования.

**- Результат анализа каждого прогона** - список проблем - ошибок и дефектов. 

Далее происходит работа над ошибками, где каждая поднятая проблема идентифицируется, относится к соответствующему модулю и разработчику, приоритезируется и отслеживается. 

Исправленный и собранный для тестирования build поступает на следующий цикл тестирования, и цикл повторяется. 

### Издержки тестирования

Чем больше трудозатрат вкладывается в процесс тестирования, тем меньше ошибок в продукте остается незамеченными. 

Идеальный продукт для релиза = баланс между затратами на получение ПО и избытком качества, которое не востребовано заказчиком приложения.

### Методы тестирования и отладки:

- Статические методы тестирования

- Модульное тестирование

- Интеграционное тестирование

- Системное тестирование

- Тестирование реального окружения и реального времени.

## Планирование активности тестирования

- оптимальное распределение ресурсов между всеми типами тестирования.

## Фазы процесса тестирования
В процессе тестирования выделяют следующие фазы:

### 1. Определение целей (требований к тестированию), включающее следующую конкретизацию: 
	a) какие части системы будут тестироваться
	
	b) какие аспекты их работы будут выбраны для проверки
	
	c) каково желаемое качество и т.п.

### 2. Планирование: 
#### 1) создание графика (расписания) разработки тестов для каждой тестируемой подсистемы; 
	
#### 2) оценка необходимых человеческих, программных и аппаратных ресурсов; 
	
#### 3) разработка расписания тестовых циклов. Расписание тестирования обязательно должно быть согласовано с расписанием разработки создаваемой системы.
Тестовый цикл – это цикл исполнения тестов, включающий фазы 4 и 5 тестового процесса; прогон разработанных тестов на конкретном билде. 

Тестовый цикл включает следующую последовательность действий:
##### a) Проверка готовности системы и тестов к проведению тестового цикла:
		
		- проверка, что все тесты разработаны и помещены в систему версионного контроля.
		
		- проверка, что все подсистемы разработаны и помещены в систему версионного контроля.
		
		- проверка, что разработана и задокументирована процедура определения и создания билда.
		
		- проверка некоторых дополнительных критериев.

##### b) Подготовка тестовой машины в соответствии с требованиями, определенными на этапе планирования (например, полная очистка и переустановка системного программного обеспечения). Конфигурация тестовой машины и билд должны быть однозначно воспроизводимыми.
		
##### c) Воспроизведение среза системы.

##### d) Прогон тестов в соответствии с задокументированными процедурами.

##### e) Сохранение тестовых протоколов (test log). 

##### f) Анализ протоколов тестирования и принятие решения о том прошел или не прошел каждый из тестов (Pass/Fail).

##### g) Анализ и документирование результатов цикла.

Последний перед выпуском продукта тестовый цикл (финальный) не должен включать изменений кода билда или тестируемой системы. Финальный цикл необходим для гарантии достоверности результатов тестирования.

#### Тестовый план

= артефакт стадии планирования тестирования; документ, или набор документов, содержащий следующую информацию:

- **Тестовые ресурсы.**

- **Перечень функций и подсистем**, подлежащих тестированию.

- **Тестовую стратегию**, включающую:
  - Анализ функций и подсистем с целью определения наиболее слабых мест, где появление дефектов наиболее вероятно.
  - Определение стратегии выбора входных данных для тестирования с помощью покрытия классов входных и выходных данных, анализа крайних значений, покрытия модели использования, анализа временной линии и т.п. Выбранную стратегию необходимо обосновать и задокументировать.
  - Определение потребности в автоматизированной системе тестирования и дизайн такой системы

**- Расписание тестовых циклов**

 ![image](https://user-images.githubusercontent.com/82804334/167304782-7c879b1c-f04a-42a4-81ae-899fff158eaf.png)

**- Фиксация тестовой конфигураци**и: состав и конкретные параметры программного окружения.

![image](https://user-images.githubusercontent.com/82804334/167304807-cb139ee6-9698-490c-826e-ec55212102cd.png)

**- Определение списка тестовых метрик**, которые необходимо собрать и проанализировать. Например, метрик, оценивающих степень покрытия тестами набора требований, степень покрытия кода тестируемой системы, количество и уровень серьезности дефектов, объем тестового кода и другие характеристики.
	
### 3. Разработка тестов (тестового кода для тестируемой системы, или кода системы автоматизации тестирования и тестовых процедур, выполняемых вручную).

### 4. Выполнение тестов: реализация тестовых циклов.

### 5. Анализ результатов.

### 6. После анализа результатов возможно повторение процесса тестирования, начиная с пунктов 3, 2 или даже 1.



## Типы тестирования

### по виду подсистемы или продукта:

1. Тестирование **основной функциональности**

2. Тестирование **инсталляции** (тестирование сценариев первичной инсталляции системы, сценариев повторной инсталляции (поверх уже существующей копии), тестирование деинсталляции, тестирование инсталляции в условиях наличия ошибок в инсталлируемом пакете, в окружении или в сценарии и т.п.)

3. Тестирование **пользовательской документации** (проверка полноты и понятности описания правил и особенностей использования продукта, наличие описания всех сценариев и функциональности, синтаксис и грамматику языка, работоспособность примеров и т.п.)

   **3.1 Тестирование спецификации/требований **

Для каждого требования пишется один или более тестов, которые в совокупности должны проверить выполнение данного требования в продукте.

   **3.2 Тестирование сценариев**

Разработка тестов на использовании сценариев:

         3.2.1 Определить модель использования: операционное окружение продукта, пользователя, другой продукт, аппаратная часть и т.п. (все, с чем продукт обменивается информацией)
	 3.2.2 Разработать сценарии использования продукта. Описание сценария может быть строго определенным, параметризованным или разрешать некоторую степень неопределенности. 
	 3.2.3 Разработать набор тестов, покрывающих заданные сценарии. Каждый тест может покрывать один сценарий, несколько сценариев, или, наоборот, часть сценария.

Использование сценариев не требует наличия полной формальной спецификации требований.
Использование сценариев направляет тестирование на проверку конкретных режимов использования продукта, что позволяет находить дефекты, которые метод тестирования по требованиям может пропустить.

   **3.3 Ручная разработка тестов**
    
Гибкий способ разработки тестов, но трудозатратный, поэтому использоуют специальные тестовые скрипты и генераторы тестов.

   **3.4 Генерация тестов**
   
В настоящее время некоторые языки спецификаций, используемые для описания алгоритмов тестирования, могут быть использованы для генерации тестового кода, например, генерация кода из языка MSC. 

![image](https://user-images.githubusercontent.com/82804334/167305872-5964b350-2c52-4c76-b5c8-0f8a89072c91.png)





### по способу выбора входных значений:

1. Функциональное тестирование:

   i) Покрытие функциональных требований.
   
   ii) Покрытие сценариев использования.
   
2. Стрессовое тестирование (проверяются экстремальные режимы использования продукта)
3. Тестирование граничных значений.
4. Тестирование производительности.
5. Тестирование на соответствие стандартам.
6. Тестирование совместимости с другими программно-аппаратными комплексами.
7. Тестирование работы с окружением.
8. Тестирование работы на конкретной платформе

В реальных разработках используются и комбинируются различные типы тестов для обеспечения спланированного качества продукта.
